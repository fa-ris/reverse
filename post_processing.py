'''
Code written by Faris Osama Qadan on 11/14/2022.
Post-processing Python script for use on the generated DOT file (control flow graph [CFG]) using pin_cfg.
It is designed to run completely after the Pin tool has run (total post-processing).
Important note: the pre-requisite of this program is that the previously generated CFG is correct, meaning it may or may not output the 'right' result on MY CFG file.
Main resources used: NetworkX documentation, Pin C++ tool output.
This program should be run using a generated CFG. 
'''

import networkx as nx

# Firstly, turn the CFG generated in Lab 5 to one easily processable by nx functions. DOT file parsing and cleaning.
l5_cfg_rel_dir= "cfg.dot" # relative address of CFG DOT file produced from Lab 5 script -- MODIFY THIS IF RELATIVE ADDRESS OF CFG IS DIFFERENT!!!
edge_list = [] # empty array to be populated with str arrays of edges
with open(l5_cfg_rel_dir, mode="r") as s:
    edges = [line.strip('\n') for line in s.readlines()] # read lines of DOT file into list of edges (unprocessed, still)
i = 0 # to make sure we are skipping over "digraph controlflow {" in parsing
for edge in edges:
    # this condition also handles the erronous edges produced by Lab 5 C++ program
    if i == 0 or len(edge.split(" -> ")) != 2:
        i += 1
        continue
    temp = edge.split('" -> "')
    temp[0] = temp[0][1:].strip("\"").strip().replace("-", "0x")
    temp[1] = temp[1][:-2].strip("\"").strip().replace("-", "0x")
    if len(edge_list) > 0 and edge_list[-1] == (temp[0], temp[1]):
        continue
    edge_list.append((temp[0], temp[1]))
cfg_graph = nx.DiGraph(edge_list, name="CFG DiGraph") # instantiate and populate our CFG DiGraph

# Now that CFG is set up, we find the immediate post-dominator list. Nx is slightly useful here with the immediate_dominators(function).
r_cfg_graph = cfg_graph.reverse(copy=True) # domination here implies post-domination in original CFG
ipd_root = None # first 'start' node for the immediate post dominator graph
for node in r_cfg_graph.nodes():
    if not len(list(nx.bfs_predecessors(r_cfg_graph, node))): # BFS preferable to DFS as it is slightly faster over large inputs (same followed below)
        ipd_root = node
        break
if not ipd_root:
    print("Likely faulty CFG graph input. Try again...")
ipd = nx.immediate_dominators(r_cfg_graph, ipd_root) # NetworkX function to get a dictionary of immediate dominators
ipd_graph = nx.DiGraph(name="Immediate Post Dominator DiGraph") # turn that dictionary into a graph
for node in ipd:
    ipd_graph.add_edge(ipd[node], node) # conserve order from the ipd dictionary generated by NetworkX function

# The penultimate step before writing to the file: we populate the actual CDG.
cdg_graph = nx.DiGraph(name="Control Dependence Graph") # finally, instantiation of CDG
cdg_graph.add_nodes_from(cfg_graph) # the CDG will have at least as many nodes as the CFG
for edge in cfg_graph.edges():
    # LCA only defined on DAGs [learnt the hard way :)]
    if nx.is_directed_acyclic_graph(ipd_graph): # although condition is neccessary, I believe this area causes an error in my algorithm's results
        lowest_ancestor = nx.lowest_common_ancestor(ipd_graph, edge[0], edge[1])
        second = edge[1]
        j = len(nx.bfs_predecessors(ipd_graph, edge[1])[0])
        # go through common ancestors and predeccessors until they meet, then proceed
        while j > -1 and second > lowest_ancestor: # while still greater than the LCA...
            cdg_graph.add_edge(edge[0], second) # add an edge to indicate control dependance between u and this decreasing v each time [(u, v)]
            second = list(nx.bfs_predecessors(ipd_graph, edge[1]))[j - 1] # set 'second' iterator variable to next vertex in line
            j -= 1 # and decrement in order to meet one of the ending conditions and proceed

# Complete population of the CDG creating edges for isolated vertices (ie: only control dependent on 'start').
cfg_temp_s = None
for node in cfg_graph.nodes():
    if not len(list(nx.bfs_predecessors(cfg_graph, node))): # BFS preferable for predecessor search
        cfg_temp_s = node
        break
if not cfg_temp_s:
    print("Likely faulty CFG graph input. Try again...")
for node in cdg_graph.nodes():
    # look for vertices with degree = 0 if CFG tested valid
    if not nx.degree(cdg_graph, node) and cfg_temp_s:
        cdg_graph.add_edge(cfg_temp_s, node) # simply add an edge between isolated vertices and the starting point of WinMain

# Finally, we write back to an output file (cdg.dot, or whatever output file is to be named -- see below).
fname = "cdg.dot"
f = open(fname, mode="w")
fstream = "digraph controlflow {"
for edge in cdg_graph.edges():
    fstream += "\n  \"" + edge[0] + "\" -> \"" + edge[1] + "\";"
fstream += "\n}"
f.write(fstream)
f.close()